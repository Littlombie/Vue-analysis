{"remainingRequest":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\WWW\\GitHub\\Vue-analysis\\docs\\lifeCycle\\index.md?vue&type=template&id=308d2172&","dependencies":[{"path":"D:\\WWW\\GitHub\\Vue-analysis\\docs\\lifeCycle\\index.md","mtime":1540716302268},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540716305167},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1540716351147},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540716305167},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js","mtime":1540716351142},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1540716355267}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"vue的生命周期方法\\\"><a href=\\\"#vue的生命周期方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Vue的生命周期方法</h1> <ul><li><p>研究方向</p> <ul><li>hook机制</li></ul></li> <li><p>研究方法</p> <ul><li>各个hook在哪个阶段触发，为啥会在这个阶段触发？触发这个钩子可以改变什么或者得到什么？</li></ul></li></ul> <hr> <h2 id=\\\"钩子函数（hook）\\\"><a href=\\\"#钩子函数（hook）\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 钩子函数（Hook）</h2> <p>钩子是Windows消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息；\\n钩子机制允许应用程序截获处理window消息或特定事件，\\n钩子函数可以理解为js运行进程中在其特定段时的回调函数</p> <h2 id=\\\"什么是生命周期？\\\"><a href=\\\"#什么是生命周期？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 什么是生命周期？</h2> <p>生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子\\n<img src=\\\"https://github.com/Littlombie/Vue-analysis/blob/master/02-lifeCycle/LifeCycle1.png?raw=true\\\" alt=\\\"vue 的生命周期\\\"></p> <ul><li>图中 数据观测：</li></ul> <p>在new Vue() 时 开始观测数据</p> <ul><li><code>init event &amp; lifeCycle</code>:  表示<code>new Vue</code> 后事件和生命周期的<code>init</code></li> <li>当<code>created</code>完成之后，它会去判断<code>instance</code>（实例）里面是否含有<code>“el”option</code>（选项），如果没有的话，它会调用<code>vm.$mount(el)</code>这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有<code>“template”</code>这个选项，如果有的话，它会把<code>template</code>解析成一个<code>render function</code> ，这是一个<code>template</code>编译的过程，结果是解析成了<code>render</code>函数：</li></ul> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>render (h) {\\n  return h('div', {}, this.text)\\n}\\n</code></pre></div><p><code>render</code>函数里面的传参h就是Vue里面的<code>createElement</code>方法，<code>return</code>返回一个<code>createElement</code>方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。</p> <p>使用render函数的结果和我们之前使用<code>template</code>解析出来的结果是一样的。<code>render</code>函数是发生在<code>beforeMount</code>和<code>mounted</code>之间的，这也从侧面说明了，在<code>beforeMount</code>的时候，<code>$el</code>还只是我们在HTML里面写的节点，然后到<code>mounted</code>的时候，它就把渲染出来的内容挂载到了<code>DOM</code>节点上。这中间的过程其实是执行了<code>render function</code>的内容。</p> <p>在使用<code>.vue</code>文件开发的过程当中，我们在里面写了<code>template</code>模板，在经过了<code>vue-loader</code>的处理之后，就变成了<code>render function</code>，最终放到了<code>vue-loader</code>解析过的文件里面。这样做有什么好处呢？原因是由于在解析<code>template</code>变成<code>render function</code>的过程，是一个非常耗时的过程，<code>vue-loader</code>帮我们处理了这些内容之后，当我们在页面上执行<code>vue</code>代码的时候，效率会变得更高。</p> <p><code>beforeMount</code>在有了<code>render function</code>的时候才会执行，当执行完<code>render function</code>之后，就会调用<code>mounted</code>这个钩子，在<code>mounted</code>挂载完毕之后，这个实例就算是走完流程了。\\n后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用<code>beforeUpdate</code>，然后经过<code>Virtual DOM</code>，最后<code>updated</code>更新完毕。当组件被销毁的时候，它会调用<code>beforeDestory</code>，以及<code>destoryed</code>。</p> <h2 id=\\\"生命周期的钩子-lifecyclehook\\\"><a href=\\\"#生命周期的钩子-lifecyclehook\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 生命周期的钩子 (lifecyclehook)</h2> <p>Vue所有的生命周期钩子自动绑定在this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此this与你期待的Vue实例不同。</p> <table><thead><tr><th>生命周期中的钩子函数</th> <th>组建状态</th> <th>最佳实践</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>实例初始化之后,this指向创建的实例，此时还不能访问到<code>data</code>,<code>computed</code>,<code>watch</code>,<code>methods</code>上的数据和方法</td> <td>常用于初始化非响应式变量</td></tr> <tr><td>created</td> <td>实例创建完成，可以访问到 <code>data</code>,<code>computed</code>,<code>watch</code>,<code>methods</code>上的数据和方法，未挂载到dom 上，不能访问<code>#el</code> 属性， <code>$ref</code>属性d额内容为空数组</td> <td>常用语简单的<code>ajax请求</code>,页面的初始化</td></tr> <tr><td>beforeMount</td> <td>在挂载开始前被调用，<code>beforeMount</code>之前，会找到对应的<code>template</code>，并编译成<code>render</code>函数</td> <td>-</td></tr> <tr><td>mounted</td> <td>实例挂载到DOM上，此时可以通过<code>DOM API</code> 获取到<code>DOM</code> 节点，<code>$ref</code> 属性可以访问</td> <td>常用于获取vnode信息和操作，<code>ajax</code>请求</td></tr> <tr><td>beforeUpdate</td> <td>响应式数据更新时调用，发生在虚拟DOM打补丁之前</td> <td>适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</td></tr> <tr><td>updated</td> <td>虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</td> <td>避免在这个钩子函数中操作数据，可能陷入死循环</td></tr> <tr><td>beforeDestroy</td> <td>实例销毁之前调用。这一步，实力任然完全可用，<code>this</code>仍能获取到实例</td> <td>常用于销毁定时器，解绑迁居时间，销毁插件对象等操作</td></tr> <tr><td>destroyed</td> <td>实力销毁后调用，调用后，Vue实例只是的所有东西都会解绑，所有的事件监听器会被移除，所有的姿势里也会被销毁</td> <td>在此也可以用于销毁定时器</td></tr> <tr><td></td> <td></td> <td></td></tr></tbody></table> <p>注：</p> \"),_vm._ssrNode(\"<ul>\",\"</ul>\",[_vm._ssrNode(\"<li><p>created阶段的<code>ajax</code>请求与<code>mounted</code>请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，此时如果做<code>DOM</code>请求时会报错,页面还没有渲染出来</p></li> \"),_vm._ssrNode(\"<li>\",\"</li>\",[_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 \"),_vm._ssrNode(\"<a href=\\\"https://blog.csdn.net/shuidinaozhongyan/article/details/72630573\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"<code>vm.$nextTick</code>\"),_c('OutboundLink')],2),_vm._ssrNode(\"\\n(https://blog.csdn.net/sinat_17775997/article/details/71638144)\")],2)]),_vm._ssrNode(\" <li><p><code>beforeCreate</code>，<code>created</code>，<code>beforeMount</code>，<code>mounted</code> 是自动被调用</p></li> <li><p><code>beforeUpdate</code>, <code>updated</code>,<code>beforeDestroy</code>,<code>destroyed</code> 是手动调用</p></li> <li><p>子组件的<code>created</code> 优先于父组件的<code>created</code> 执行， 父组件的<code>beforeCreate</code> 优先于子组件的<code>beforeCreate</code></p></li> <li><p>子组件的<code>mounted</code>优先于父组件的<code>mounted</code>， 父组件的<code>beforeMount</code> 优先于子组件的 <code>beforeMount</code></p></li> <li><p>子组件的<code>destroyed</code>优先于父组件的<code>beforeDestroy</code>， 父组件的<code>beforeDestroy</code> 优先于子组件的 <code>beforeDestroy</code></p></li>\")],2),_vm._ssrNode(\" <h2 id=\\\"activated-deactivated\\\"><a href=\\\"#activated-deactivated\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> activated &amp; deactivated</h2> <p>最后还有 两个钩子函数没显示：activated &amp; deactivated\\n使用<code>&lt;keep-alive&gt;</code>会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务</p> <ul><li><p>activated： 在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用，该钩子在服务器端渲染期间不被调用。</p></li> <li><p>deactivated： keep-alive组件停用时调用。该钩子在服务端渲染期间不被调用。</p> <p>组件内的离开当前路由钩子beforeRouteLeave =&gt;  路由前置守卫 beforeEach =&gt;\\n全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由)\\n// 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated\\n// 如果进入的路由也没有缓存的话  全局后置钩子afterEach=&gt;销毁 destroyed=&gt; beforeCreate等</p></li></ul> <h2 id=\\\"路由导航守卫\\\"><a href=\\\"#路由导航守卫\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 路由导航守卫</h2> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5b41bdef6fb9a04fe63765f1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Vue的钩子函数 [路由导航守卫、keep-alive、生命周期钩子]\"),_c('OutboundLink')],2)]),_vm._ssrNode(\" \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"实例demo：\\n见\"),_vm._ssrNode(\"<a href=\\\"https://github.com/Littlombie/Vue-analysis/tree/master/02-lifeCycle/template\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"<code>template</code>\"),_c('OutboundLink')],2),_vm._ssrNode(\" \\n参考文档：<br> \"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5ad10800f265da23826e681e?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"如何解释vue的生命周期才能令面试官满意？\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"http://blog.poetries.top/2018/08/26/vue-lifecircle/?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"vue生命周期（五）\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555022&idx=1&sn=552856ad4af7bb9560217f6deec65270&chksm=8025530fb752da190830e52ca6a9b24d1e7440e1d6cccbfff6355f7583d4f4749400e541739e\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"深入 Vue 生命周期\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://segmentfault.com/a/1190000008771768?_ea=1739750\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Vue 实例中的生命周期钩子详解\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://www.cnblogs.com/locim/p/8892738.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Vue.js源码解读\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"http://blog.51cto.com/9195095/1963227\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"生命周期\"),_c('OutboundLink')],2),_vm._ssrNode(\" \"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5b41bdef6fb9a04fe63765f1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://blog.csdn.net/xdnloveme/article/details/78035065\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Vue生命周期中mounted和created的区别\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://www.jb51.net/article/124737.htm\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"深入理解Vue生命周期、手动挂载及挂载子组件\"),_c('OutboundLink')],2)],2),_vm._ssrNode(\" <h2 id=\\\"遗留问题：\\\"><a href=\\\"#遗留问题：\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 遗留问题：</h2> <ul><li><p>兄弟组件通过bus传值时的updated，beforeUpdate 生命周期顺序<br>\\n如果是通过父级派发更新事件时，beforeUpdate，和updated的顺序 都是自上到下正常顺序进行；<br>\\n如果是兄弟组件的派发顺序是beforeUpdate是从上到下，updated 的顺序是从下到上的更新顺序</p></li> <li><p>beforeCreate 有什么具体实际的用处，例举<br>\\nvue生命周期中 beforeCreate 是实例初始化完成后数据观测（data observer）和event/watcher之前被调用。</p> <p>在beforeCreate前，所有的options都会先存到vm.$options中，在beforeCreate之后，将$options里的data啦，props啦，methods啦等等一个个附到vm上，然后再触发created钩子。所以在beforeCreate的时候，通过this.message是拿不到值的，在created的时候就能通过this.message拿到值了。</p> <p>一定要在beforeCreate的时候就同步去拿data里的值的话，就是直接从this.$options.data里去拿。如果data中的初始值是简单的string，那直接this.$options.data()[&quot;message&quot;]就好.涉及到复杂点的情况，建议看看源码里是怎么处理的，具体在core/instance/state.js中的initData(vm)里。\\n还有一种方法 可以使用nextTick()，相当于做个延迟，等页面挂载完后在执行\\n使用promise</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">let</span> <span class=\\\"token constant\\\">F</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">export</span> <span class=\\\"token keyword\\\">default</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//...</span>\\n    <span class=\\\"token function\\\">data</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">{</span>\\n            dataList<span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token function\\\">beforeCreate</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token constant\\\">F</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">fetchData</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token comment\\\">//fetchData是取数方法</span>\\n            <span class=\\\"token comment\\\">//...返回promise</span>\\n        <span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token function\\\">created</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token constant\\\">F</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token operator\\\">=&gt;</span><span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>dataList <span class=\\\"token operator\\\">=</span> data\\n        <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>本人理解其中原因就是一个实例初始化后的提示功能，表示此后要开始</p></li></ul>\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}
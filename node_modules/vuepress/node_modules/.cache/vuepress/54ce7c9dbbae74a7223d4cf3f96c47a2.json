{"remainingRequest":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\WWW\\GitHub\\Vue-analysis\\docs\\lifeCycle\\index.md?vue&type=template&id=24775cf6&","dependencies":[{"path":"D:\\WWW\\GitHub\\Vue-analysis\\docs\\lifeCycle\\index.md","mtime":1540664892148},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540660665436},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540660665436},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"content\" }, [\n    _vm._m(0),\n    _vm._v(\" \"),\n    _vm._m(1),\n    _vm._v(\" \"),\n    _c(\"hr\"),\n    _vm._v(\" \"),\n    _vm._m(2),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _vm._v(\n        \"钩子是Windows消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息；\\n钩子机制允许应用程序截获处理window消息或特定事件，\\n钩子函数可以理解为js运行进程中在其特定段时的回调函数\"\n      )\n    ]),\n    _vm._v(\" \"),\n    _vm._m(3),\n    _vm._v(\" \"),\n    _vm._m(4),\n    _vm._v(\" \"),\n    _vm._m(5),\n    _vm._v(\" \"),\n    _c(\"p\", [_vm._v(\"在new Vue() 时 开始观测数据\")]),\n    _vm._v(\" \"),\n    _vm._m(6),\n    _vm._v(\" \"),\n    _vm._m(7),\n    _vm._m(8),\n    _vm._v(\" \"),\n    _vm._m(9),\n    _vm._v(\" \"),\n    _vm._m(10),\n    _vm._v(\" \"),\n    _vm._m(11),\n    _vm._v(\" \"),\n    _vm._m(12),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _vm._v(\n        \"Vue所有的生命周期钩子自动绑定在this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此this与你期待的Vue实例不同。\"\n      )\n    ]),\n    _vm._v(\" \"),\n    _vm._m(13),\n    _vm._v(\" \"),\n    _c(\"p\", [_vm._v(\"注：\")]),\n    _vm._v(\" \"),\n    _c(\"ul\", [\n      _vm._m(14),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"p\", [\n          _vm._v(\n            \"mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 \"\n          ),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href:\n                  \"https://blog.csdn.net/shuidinaozhongyan/article/details/72630573\",\n                target: \"_blank\",\n                rel: \"noopener noreferrer\"\n              }\n            },\n            [_c(\"code\", [_vm._v(\"vm.$nextTick\")]), _c(\"OutboundLink\")],\n            1\n          ),\n          _vm._v(\n            \"\\n(https://blog.csdn.net/sinat_17775997/article/details/71638144)\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _vm._m(15),\n      _vm._v(\" \"),\n      _vm._m(16),\n      _vm._v(\" \"),\n      _vm._m(17),\n      _vm._v(\" \"),\n      _vm._m(18),\n      _vm._v(\" \"),\n      _vm._m(19)\n    ]),\n    _vm._v(\" \"),\n    _vm._m(20),\n    _vm._v(\" \"),\n    _vm._m(21),\n    _vm._v(\" \"),\n    _vm._m(22),\n    _vm._v(\" \"),\n    _vm._m(23),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://juejin.im/post/5b41bdef6fb9a04fe63765f1\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [\n          _vm._v(\"Vue的钩子函数 [路由导航守卫、keep-alive、生命周期钩子]\"),\n          _c(\"OutboundLink\")\n        ],\n        1\n      )\n    ]),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _vm._v(\"实例demo：\\n见\"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href:\n              \"https://github.com/Littlombie/Vue-analysis/tree/master/02-lifeCycle/template\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_c(\"code\", [_vm._v(\"template\")]), _c(\"OutboundLink\")],\n        1\n      ),\n      _vm._v(\" \"),\n      _vm._v(\"\\n参考文档：\"),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href:\n              \"https://juejin.im/post/5ad10800f265da23826e681e?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"如何解释vue的生命周期才能令面试官满意？\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href:\n              \"http://blog.poetries.top/2018/08/26/vue-lifecircle/?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"vue生命周期（五）\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href:\n              \"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555022&idx=1&sn=552856ad4af7bb9560217f6deec65270&chksm=8025530fb752da190830e52ca6a9b24d1e7440e1d6cccbfff6355f7583d4f4749400e541739e\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"深入 Vue 生命周期\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://segmentfault.com/a/1190000008771768?_ea=1739750\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"Vue 实例中的生命周期钩子详解\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://www.cnblogs.com/locim/p/8892738.html\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"Vue.js源码解读\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"http://blog.51cto.com/9195095/1963227\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"生命周期\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://juejin.im/post/5b41bdef6fb9a04fe63765f1\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [\n          _vm._v(\"Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]\"),\n          _c(\"OutboundLink\")\n        ],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://blog.csdn.net/xdnloveme/article/details/78035065\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"Vue生命周期中mounted和created的区别\"), _c(\"OutboundLink\")],\n        1\n      ),\n      _c(\"br\"),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://www.jb51.net/article/124737.htm\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [\n          _vm._v(\"深入理解Vue生命周期、手动挂载及挂载子组件\"),\n          _c(\"OutboundLink\")\n        ],\n        1\n      )\n    ]),\n    _vm._v(\" \"),\n    _vm._m(24),\n    _vm._v(\" \"),\n    _vm._m(25)\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h1\", { attrs: { id: \"vue的生命周期方法\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#vue的生命周期方法\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" Vue的生命周期方法\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _c(\"p\", [_vm._v(\"研究方向\")]),\n        _vm._v(\" \"),\n        _c(\"ul\", [_c(\"li\", [_vm._v(\"hook机制\")])])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"p\", [_vm._v(\"研究方法\")]),\n        _vm._v(\" \"),\n        _c(\"ul\", [\n          _c(\"li\", [\n            _vm._v(\n              \"各个hook在哪个阶段触发，为啥会在这个阶段触发？触发这个钩子可以改变什么或者得到什么？\"\n            )\n          ])\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"钩子函数（hook）\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#钩子函数（hook）\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 钩子函数（Hook）\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"什么是生命周期？\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#什么是生命周期？\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 什么是生命周期？\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _vm._v(\n        \"生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子\\n\"\n      ),\n      _c(\"img\", {\n        attrs: {\n          src:\n            \"https://github.com/Littlombie/Vue-analysis/blob/master/02-lifeCycle/LifeCycle1.png?raw=true\",\n          alt: \"vue 的生命周期\"\n        }\n      })\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [_c(\"li\", [_vm._v(\"图中 数据观测：\")])])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _c(\"code\", [_vm._v(\"init event & lifeCycle\")]),\n        _vm._v(\":  表示\"),\n        _c(\"code\", [_vm._v(\"new Vue\")]),\n        _vm._v(\" 后事件和生命周期的\"),\n        _c(\"code\", [_vm._v(\"init\")])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\"当\"),\n        _c(\"code\", [_vm._v(\"created\")]),\n        _vm._v(\"完成之后，它会去判断\"),\n        _c(\"code\", [_vm._v(\"instance\")]),\n        _vm._v(\"（实例）里面是否含有\"),\n        _c(\"code\", [_vm._v(\"“el”option\")]),\n        _vm._v(\"（选项），如果没有的话，它会调用\"),\n        _c(\"code\", [_vm._v(\"vm.$mount(el)\")]),\n        _vm._v(\n          \"这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有\"\n        ),\n        _c(\"code\", [_vm._v(\"“template”\")]),\n        _vm._v(\"这个选项，如果有的话，它会把\"),\n        _c(\"code\", [_vm._v(\"template\")]),\n        _vm._v(\"解析成一个\"),\n        _c(\"code\", [_vm._v(\"render function\")]),\n        _vm._v(\" ，这是一个\"),\n        _c(\"code\", [_vm._v(\"template\")]),\n        _vm._v(\"编译的过程，结果是解析成了\"),\n        _c(\"code\", [_vm._v(\"render\")]),\n        _vm._v(\"函数：\")\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"language- extra-class\" }, [\n      _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n        _c(\"code\", [\n          _vm._v(\"render (h) {\\n  return h('div', {}, this.text)\\n}\\n\")\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _c(\"code\", [_vm._v(\"render\")]),\n      _vm._v(\"函数里面的传参h就是Vue里面的\"),\n      _c(\"code\", [_vm._v(\"createElement\")]),\n      _vm._v(\"方法，\"),\n      _c(\"code\", [_vm._v(\"return\")]),\n      _vm._v(\"返回一个\"),\n      _c(\"code\", [_vm._v(\"createElement\")]),\n      _vm._v(\n        \"方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。\"\n      )\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _vm._v(\"使用render函数的结果和我们之前使用\"),\n      _c(\"code\", [_vm._v(\"template\")]),\n      _vm._v(\"解析出来的结果是一样的。\"),\n      _c(\"code\", [_vm._v(\"render\")]),\n      _vm._v(\"函数是发生在\"),\n      _c(\"code\", [_vm._v(\"beforeMount\")]),\n      _vm._v(\"和\"),\n      _c(\"code\", [_vm._v(\"mounted\")]),\n      _vm._v(\"之间的，这也从侧面说明了，在\"),\n      _c(\"code\", [_vm._v(\"beforeMount\")]),\n      _vm._v(\"的时候，\"),\n      _c(\"code\", [_vm._v(\"$el\")]),\n      _vm._v(\"还只是我们在HTML里面写的节点，然后到\"),\n      _c(\"code\", [_vm._v(\"mounted\")]),\n      _vm._v(\"的时候，它就把渲染出来的内容挂载到了\"),\n      _c(\"code\", [_vm._v(\"DOM\")]),\n      _vm._v(\"节点上。这中间的过程其实是执行了\"),\n      _c(\"code\", [_vm._v(\"render function\")]),\n      _vm._v(\"的内容。\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _vm._v(\"在使用\"),\n      _c(\"code\", [_vm._v(\".vue\")]),\n      _vm._v(\"文件开发的过程当中，我们在里面写了\"),\n      _c(\"code\", [_vm._v(\"template\")]),\n      _vm._v(\"模板，在经过了\"),\n      _c(\"code\", [_vm._v(\"vue-loader\")]),\n      _vm._v(\"的处理之后，就变成了\"),\n      _c(\"code\", [_vm._v(\"render function\")]),\n      _vm._v(\"，最终放到了\"),\n      _c(\"code\", [_vm._v(\"vue-loader\")]),\n      _vm._v(\"解析过的文件里面。这样做有什么好处呢？原因是由于在解析\"),\n      _c(\"code\", [_vm._v(\"template\")]),\n      _vm._v(\"变成\"),\n      _c(\"code\", [_vm._v(\"render function\")]),\n      _vm._v(\"的过程，是一个非常耗时的过程，\"),\n      _c(\"code\", [_vm._v(\"vue-loader\")]),\n      _vm._v(\"帮我们处理了这些内容之后，当我们在页面上执行\"),\n      _c(\"code\", [_vm._v(\"vue\")]),\n      _vm._v(\"代码的时候，效率会变得更高。\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _c(\"code\", [_vm._v(\"beforeMount\")]),\n      _vm._v(\"在有了\"),\n      _c(\"code\", [_vm._v(\"render function\")]),\n      _vm._v(\"的时候才会执行，当执行完\"),\n      _c(\"code\", [_vm._v(\"render function\")]),\n      _vm._v(\"之后，就会调用\"),\n      _c(\"code\", [_vm._v(\"mounted\")]),\n      _vm._v(\"这个钩子，在\"),\n      _c(\"code\", [_vm._v(\"mounted\")]),\n      _vm._v(\n        \"挂载完毕之后，这个实例就算是走完流程了。\\n后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用\"\n      ),\n      _c(\"code\", [_vm._v(\"beforeUpdate\")]),\n      _vm._v(\"，然后经过\"),\n      _c(\"code\", [_vm._v(\"Virtual DOM\")]),\n      _vm._v(\"，最后\"),\n      _c(\"code\", [_vm._v(\"updated\")]),\n      _vm._v(\"更新完毕。当组件被销毁的时候，它会调用\"),\n      _c(\"code\", [_vm._v(\"beforeDestory\")]),\n      _vm._v(\"，以及\"),\n      _c(\"code\", [_vm._v(\"destoryed\")]),\n      _vm._v(\"。\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"生命周期的钩子-lifecyclehook\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: {\n            href: \"#生命周期的钩子-lifecyclehook\",\n            \"aria-hidden\": \"true\"\n          }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 生命周期的钩子 (lifecyclehook)\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"table\", [\n      _c(\"thead\", [\n        _c(\"tr\", [\n          _c(\"th\", [_vm._v(\"生命周期中的钩子函数\")]),\n          _vm._v(\" \"),\n          _c(\"th\", [_vm._v(\"组建状态\")]),\n          _vm._v(\" \"),\n          _c(\"th\", [_vm._v(\"最佳实践\")])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"tbody\", [\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"beforeCreate\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"实例初始化之后,this指向创建的实例，此时还不能访问到\"),\n            _c(\"code\", [_vm._v(\"data\")]),\n            _vm._v(\",\"),\n            _c(\"code\", [_vm._v(\"computed\")]),\n            _vm._v(\",\"),\n            _c(\"code\", [_vm._v(\"watch\")]),\n            _vm._v(\",\"),\n            _c(\"code\", [_vm._v(\"methods\")]),\n            _vm._v(\"上的数据和方法\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [_vm._v(\"常用于初始化非响应式变量\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"created\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"实例创建完成，可以访问到 \"),\n            _c(\"code\", [_vm._v(\"data\")]),\n            _vm._v(\",\"),\n            _c(\"code\", [_vm._v(\"computed\")]),\n            _vm._v(\",\"),\n            _c(\"code\", [_vm._v(\"watch\")]),\n            _vm._v(\",\"),\n            _c(\"code\", [_vm._v(\"methods\")]),\n            _vm._v(\"上的数据和方法，未挂载到dom 上，不能访问\"),\n            _c(\"code\", [_vm._v(\"#el\")]),\n            _vm._v(\" 属性， \"),\n            _c(\"code\", [_vm._v(\"$ref\")]),\n            _vm._v(\"属性d额内容为空数组\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"常用语简单的\"),\n            _c(\"code\", [_vm._v(\"ajax请求\")]),\n            _vm._v(\",页面的初始化\")\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"beforeMount\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"在挂载开始前被调用，\"),\n            _c(\"code\", [_vm._v(\"beforeMount\")]),\n            _vm._v(\"之前，会找到对应的\"),\n            _c(\"code\", [_vm._v(\"template\")]),\n            _vm._v(\"，并编译成\"),\n            _c(\"code\", [_vm._v(\"render\")]),\n            _vm._v(\"函数\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [_vm._v(\"-\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"mounted\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"实例挂载到DOM上，此时可以通过\"),\n            _c(\"code\", [_vm._v(\"DOM API\")]),\n            _vm._v(\" 获取到\"),\n            _c(\"code\", [_vm._v(\"DOM\")]),\n            _vm._v(\" 节点，\"),\n            _c(\"code\", [_vm._v(\"$ref\")]),\n            _vm._v(\" 属性可以访问\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"常用于获取vnode信息和操作，\"),\n            _c(\"code\", [_vm._v(\"ajax\")]),\n            _vm._v(\"请求\")\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"beforeUpdate\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [_vm._v(\"响应式数据更新时调用，发生在虚拟DOM打补丁之前\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\n              \"适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"updated\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\n              \"虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作\"\n            )\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [_vm._v(\"避免在这个钩子函数中操作数据，可能陷入死循环\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"beforeDestroy\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"实例销毁之前调用。这一步，实力任然完全可用，\"),\n            _c(\"code\", [_vm._v(\"this\")]),\n            _vm._v(\"仍能获取到实例\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\"常用于销毁定时器，解绑迁居时间，销毁插件对象等操作\")\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [\n          _c(\"td\", [_vm._v(\"destroyed\")]),\n          _vm._v(\" \"),\n          _c(\"td\", [\n            _vm._v(\n              \"实力销毁后调用，调用后，Vue实例只是的所有东西都会解绑，所有的事件监听器会被移除，所有的姿势里也会被销毁\"\n            )\n          ]),\n          _vm._v(\" \"),\n          _c(\"td\", [_vm._v(\"在此也可以用于销毁定时器\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"tr\", [_c(\"td\"), _vm._v(\" \"), _c(\"td\"), _vm._v(\" \"), _c(\"td\")])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"li\", [\n      _c(\"p\", [\n        _vm._v(\"created阶段的\"),\n        _c(\"code\", [_vm._v(\"ajax\")]),\n        _vm._v(\"请求与\"),\n        _c(\"code\", [_vm._v(\"mounted\")]),\n        _vm._v(\n          \"请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，此时如果做\"\n        ),\n        _c(\"code\", [_vm._v(\"DOM\")]),\n        _vm._v(\"请求时会报错,页面还没有渲染出来\")\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"li\", [\n      _c(\"p\", [\n        _c(\"code\", [_vm._v(\"beforeCreate\")]),\n        _vm._v(\"，\"),\n        _c(\"code\", [_vm._v(\"created\")]),\n        _vm._v(\"，\"),\n        _c(\"code\", [_vm._v(\"beforeMount\")]),\n        _vm._v(\"，\"),\n        _c(\"code\", [_vm._v(\"mounted\")]),\n        _vm._v(\" 是自动被调用\")\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"li\", [\n      _c(\"p\", [\n        _c(\"code\", [_vm._v(\"beforeUpdate\")]),\n        _vm._v(\", \"),\n        _c(\"code\", [_vm._v(\"updated\")]),\n        _vm._v(\",\"),\n        _c(\"code\", [_vm._v(\"beforeDestroy\")]),\n        _vm._v(\",\"),\n        _c(\"code\", [_vm._v(\"destroyed\")]),\n        _vm._v(\" 是手动调用\")\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"li\", [\n      _c(\"p\", [\n        _vm._v(\"子组件的\"),\n        _c(\"code\", [_vm._v(\"created\")]),\n        _vm._v(\" 优先于父组件的\"),\n        _c(\"code\", [_vm._v(\"created\")]),\n        _vm._v(\" 执行， 父组件的\"),\n        _c(\"code\", [_vm._v(\"beforeCreate\")]),\n        _vm._v(\" 优先于子组件的\"),\n        _c(\"code\", [_vm._v(\"beforeCreate\")])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"li\", [\n      _c(\"p\", [\n        _vm._v(\"子组件的\"),\n        _c(\"code\", [_vm._v(\"mounted\")]),\n        _vm._v(\"优先于父组件的\"),\n        _c(\"code\", [_vm._v(\"mounted\")]),\n        _vm._v(\"， 父组件的\"),\n        _c(\"code\", [_vm._v(\"beforeMount\")]),\n        _vm._v(\" 优先于子组件的 \"),\n        _c(\"code\", [_vm._v(\"beforeMount\")])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"li\", [\n      _c(\"p\", [\n        _vm._v(\"子组件的\"),\n        _c(\"code\", [_vm._v(\"destroyed\")]),\n        _vm._v(\"优先于父组件的\"),\n        _c(\"code\", [_vm._v(\"beforeDestroy\")]),\n        _vm._v(\"， 父组件的\"),\n        _c(\"code\", [_vm._v(\"beforeDestroy\")]),\n        _vm._v(\" 优先于子组件的 \"),\n        _c(\"code\", [_vm._v(\"beforeDestroy\")])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"activated-deactivated\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#activated-deactivated\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" activated & deactivated\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _vm._v(\"最后还有 两个钩子函数没显示：activated & deactivated\\n使用\"),\n      _c(\"code\", [_vm._v(\"<keep-alive>\")]),\n      _vm._v(\n        \"会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务\"\n      )\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _c(\"p\", [\n          _vm._v(\n            \"activated： 在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用，该钩子在服务器端渲染期间不被调用。\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"p\", [\n          _vm._v(\n            \"deactivated： keep-alive组件停用时调用。该钩子在服务端渲染期间不被调用。\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"p\", [\n          _vm._v(\n            \"组件内的离开当前路由钩子beforeRouteLeave =>  路由前置守卫 beforeEach =>\\n全局后置钩子afterEach => deactivated 离开缓存组件 => activated 进入缓存组件(如果你进入的也是缓存路由)\\n// 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated\\n// 如果进入的路由也没有缓存的话  全局后置钩子afterEach=>销毁 destroyed=> beforeCreate等\"\n          )\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"路由导航守卫\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#路由导航守卫\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 路由导航守卫\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"遗留问题：\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#遗留问题：\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 遗留问题：\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _c(\"p\", [\n          _vm._v(\"兄弟组件通过bus传值时的updated，beforeUpdate 生命周期顺序\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\n如果是通过父级派发更新事件时，beforeUpdate，和updated的顺序 都是自上到下正常顺序进行；\"\n          ),\n          _c(\"br\"),\n          _vm._v(\n            \"\\n如果是兄弟组件的派发顺序是beforeUpdate是从上到下，updated 的顺序是从下到上的更新顺序\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"p\", [\n          _vm._v(\"beforeCreate 有什么具体实际的用处，例举\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nvue生命周期中 beforeCreate 是实例初始化完成后数据观测（data observer）和event/watcher之前被调用。\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"p\", [\n          _vm._v(\n            \"在beforeCreate前，所有的options都会先存到vm.$options中，在beforeCreate之后，将$options里的data啦，props啦，methods啦等等一个个附到vm上，然后再触发created钩子。所以在beforeCreate的时候，通过this.message是拿不到值的，在created的时候就能通过this.message拿到值了。\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"p\", [\n          _vm._v(\n            '一定要在beforeCreate的时候就同步去拿data里的值的话，就是直接从this.$options.data里去拿。如果data中的初始值是简单的string，那直接this.$options.data()[\"message\"]就好.涉及到复杂点的情况，建议看看源码里是怎么处理的，具体在core/instance/state.js中的initData(vm)里。\\n还有一种方法 可以使用nextTick()，相当于做个延迟，等页面挂载完后在执行\\n使用promise'\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"language-javascript extra-class\" }, [\n          _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n            _c(\"code\", [\n              _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n                _vm._v(\"let\")\n              ]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token constant\" } }, [_vm._v(\"F\")]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=\")]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n                _vm._v(\"null\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\";\")\n              ]),\n              _vm._v(\"\\n\"),\n              _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n                _vm._v(\"export\")\n              ]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n                _vm._v(\"default\")\n              ]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"{\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token comment\" } }, [\n                _vm._v(\"//...\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token function\" } }, [\n                _vm._v(\"data\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"(\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\")\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"{\")\n              ]),\n              _vm._v(\"\\n        \"),\n              _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n                _vm._v(\"return\")\n              ]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"{\")\n              ]),\n              _vm._v(\"\\n            dataList\"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\":\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"[\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"]\")\n              ]),\n              _vm._v(\"\\n        \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"}\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"}\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\",\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token function\" } }, [\n                _vm._v(\"beforeCreate\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"(\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\")\")\n              ]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"{\")\n              ]),\n              _vm._v(\"\\n        \"),\n              _c(\"span\", { attrs: { class: \"token constant\" } }, [_vm._v(\"F\")]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=\")]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token function\" } }, [\n                _vm._v(\"fetchData\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"(\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token comment\" } }, [\n                _vm._v(\"//fetchData是取数方法\")\n              ]),\n              _vm._v(\"\\n            \"),\n              _c(\"span\", { attrs: { class: \"token comment\" } }, [\n                _vm._v(\"//...返回promise\")\n              ]),\n              _vm._v(\"\\n        \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\")\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"}\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\",\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token function\" } }, [\n                _vm._v(\"created\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"(\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\")\")\n              ]),\n              _vm._v(\" \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"{\")\n              ]),\n              _vm._v(\"\\n        \"),\n              _c(\"span\", { attrs: { class: \"token constant\" } }, [_vm._v(\"F\")]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\".\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token function\" } }, [\n                _vm._v(\"then\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"(\")\n              ]),\n              _vm._v(\"data\"),\n              _c(\"span\", { attrs: { class: \"token operator\" } }, [\n                _vm._v(\"=>\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"{\")\n              ]),\n              _vm._v(\"\\n            \"),\n              _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n                _vm._v(\"this\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\".\")\n              ]),\n              _vm._v(\"dataList \"),\n              _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=\")]),\n              _vm._v(\" data\\n        \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"}\")\n              ]),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\")\")\n              ]),\n              _vm._v(\"\\n    \"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"}\")\n              ]),\n              _vm._v(\"\\n\"),\n              _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n                _vm._v(\"}\")\n              ]),\n              _vm._v(\"\\n\")\n            ])\n          ])\n        ]),\n        _c(\"p\", [\n          _vm._v(\n            \"本人理解其中原因就是一个实例初始化后的提示功能，表示此后要开始\"\n          )\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}
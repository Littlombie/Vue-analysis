{"remainingRequest":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\WWW\\GitHub\\Vue-analysis\\docs\\vuex\\index.md?vue&type=template&id=aab0b988&","dependencies":[{"path":"D:\\WWW\\GitHub\\Vue-analysis\\docs\\vuex\\index.md","mtime":1540716302272},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540716305167},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1540716351147},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540716305167},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js","mtime":1540716351142},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1540716355267}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._m(0),_vm._v(\" \"),_vm._m(1),_vm._v(\" \"),_c('hr'),_vm._v(\" \"),_vm._m(2),_vm._v(\" \"),_vm._m(3),_vm._v(\" \"),_c('p',[_vm._v(\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"状态管理模式、集中式存储管理初次了解的话感觉有点难以理解，我们通过官方文档中提供的这张图加深下理解。\")]),_vm._v(\" \"),_vm._m(4),_vm._v(\" \"),_vm._m(5),_vm._v(\" \"),_c('p',[_c('a',{attrs:{\"href\":\"https://vuex.vuejs.org/zh/\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\"}},[_vm._v(\"Vuex\"),_c('OutboundLink')],1),_vm._v(\" \"),_c('a',{attrs:{\"href\":\"https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\"}},[_vm._v(\"prop\"),_c('OutboundLink')],1)])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('h1',{attrs:{\"id\":\"vuex\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#vuex\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" Vuex\")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_c('p',[_vm._v(\"研究方向\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"state prop机制\")])])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"研究方法\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"vuex主要解决什么问题，如果不用vuex如何解决，\")]),_vm._v(\" \"),_c('li',[_vm._v(\"vuex如何管理state prop; state prop分别来处理什么内容？\")])])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('blockquote',[_c('p',[_vm._v(\"如果你在使用Vue.js，肯定有很多组件之间相互传递参数的经历。当遇到父子组件需要通信的时候，我们通常会采用 props + emit 这种方式。但当通信双方不是父子组件甚至压根不存在相关联系，或者一个状态需要共享给多个组件时，就会非常麻烦，数据也会相当难维护。其实除了传递参数的方式，我们还可以结合业务需要考虑是否用Vuex去解决。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('h2',{attrs:{\"id\":\"vuex是什么？\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#vuex是什么？\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" Vuex是什么？\")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_c('img',{attrs:{\"src\":\"https://github.com/Littlombie/Vue-analysis/blob/6bcf8295feb4829d3b02520b912bbdbb0349d61f/10-Vuex/images/state.png?raw=true\",\"alt\":\"vue-State\"}})])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('h2',{attrs:{\"id\":\"参考\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#参考\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 参考\")])}]\n\nexport { render, staticRenderFns }"]}
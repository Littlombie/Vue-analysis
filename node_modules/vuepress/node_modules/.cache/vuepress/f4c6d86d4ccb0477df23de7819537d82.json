{"remainingRequest":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\WWW\\GitHub\\Vue-analysis\\docs\\lifeCycle\\index.md?vue&type=template&id=308d2172&","dependencies":[{"path":"D:\\WWW\\GitHub\\Vue-analysis\\docs\\lifeCycle\\index.md","mtime":1541001381917},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1541001386772},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1541001427225},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1541001386772},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vue-loader\\lib\\index.js","mtime":1541001427219},{"path":"D:\\WWW\\GitHub\\Vue-analysis\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1541001430602}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"vue的生命周期方法\"><a class=\"header-anchor\" href=\"#vue的生命周期方法\" aria-hidden=\"true\">#</a> Vue的生命周期方法</h1>\n<ul>\n<li>\n<p>研究方向</p>\n<ul>\n<li>hook机制</li>\n</ul>\n</li>\n<li>\n<p>研究方法</p>\n<ul>\n<li>各个hook在哪个阶段触发，为啥会在这个阶段触发？触发这个钩子可以改变什么或者得到什么？</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"钩子函数（hook）\"><a class=\"header-anchor\" href=\"#钩子函数（hook）\" aria-hidden=\"true\">#</a> 钩子函数（Hook）</h2>\n<p>钩子是Windows消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息；\n钩子机制允许应用程序截获处理window消息或特定事件，\n钩子函数可以理解为js运行进程中在其特定段时的回调函数</p>\n<h2 id=\"什么是生命周期？\"><a class=\"header-anchor\" href=\"#什么是生命周期？\" aria-hidden=\"true\">#</a> 什么是生命周期？</h2>\n<p>生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子\n<img src=\"https://github.com/Littlombie/Vue-analysis/blob/master/02-lifeCycle/LifeCycle1.png?raw=true\" alt=\"vue 的生命周期\"></p>\n<ul>\n<li>图中 数据观测：</li>\n</ul>\n<p>在new Vue() 时 开始观测数据</p>\n<ul>\n<li><code>init event &amp; lifeCycle</code>:  表示<code>new Vue</code> 后事件和生命周期的<code>init</code></li>\n<li>当<code>created</code>完成之后，它会去判断<code>instance</code>（实例）里面是否含有<code>“el”option</code>（选项），如果没有的话，它会调用<code>vm.$mount(el)</code>这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有<code>“template”</code>这个选项，如果有的话，它会把<code>template</code>解析成一个<code>render function</code> ，这是一个<code>template</code>编译的过程，结果是解析成了<code>render</code>函数：</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>render (h) {\n  return h(&#39;div&#39;, {}, this.text)\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><code>render</code>函数里面的传参h就是Vue里面的<code>createElement</code>方法，<code>return</code>返回一个<code>createElement</code>方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。</p>\n<p>使用render函数的结果和我们之前使用<code>template</code>解析出来的结果是一样的。<code>render</code>函数是发生在<code>beforeMount</code>和<code>mounted</code>之间的，这也从侧面说明了，在<code>beforeMount</code>的时候，<code>$el</code>还只是我们在HTML里面写的节点，然后到<code>mounted</code>的时候，它就把渲染出来的内容挂载到了<code>DOM</code>节点上。这中间的过程其实是执行了<code>render function</code>的内容。</p>\n<p>在使用<code>.vue</code>文件开发的过程当中，我们在里面写了<code>template</code>模板，在经过了<code>vue-loader</code>的处理之后，就变成了<code>render function</code>，最终放到了<code>vue-loader</code>解析过的文件里面。这样做有什么好处呢？原因是由于在解析<code>template</code>变成<code>render function</code>的过程，是一个非常耗时的过程，<code>vue-loader</code>帮我们处理了这些内容之后，当我们在页面上执行<code>vue</code>代码的时候，效率会变得更高。</p>\n<p><code>beforeMount</code>在有了<code>render function</code>的时候才会执行，当执行完<code>render function</code>之后，就会调用<code>mounted</code>这个钩子，在<code>mounted</code>挂载完毕之后，这个实例就算是走完流程了。\n后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用<code>beforeUpdate</code>，然后经过<code>Virtual DOM</code>，最后<code>updated</code>更新完毕。当组件被销毁的时候，它会调用<code>beforeDestory</code>，以及<code>destoryed</code>。</p>\n<h2 id=\"生命周期的钩子-lifecyclehook\"><a class=\"header-anchor\" href=\"#生命周期的钩子-lifecyclehook\" aria-hidden=\"true\">#</a> 生命周期的钩子 (lifecyclehook)</h2>\n<p>Vue所有的生命周期钩子自动绑定在this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此this与你期待的Vue实例不同。</p>\n<table>\n<thead>\n<tr>\n<th>生命周期中的钩子函数</th>\n<th>组建状态</th>\n<th>最佳实践</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beforeCreate</td>\n<td>实例初始化之后,this指向创建的实例，此时还不能访问到<code>data</code>,<code>computed</code>,<code>watch</code>,<code>methods</code>上的数据和方法</td>\n<td>常用于初始化非响应式变量</td>\n</tr>\n<tr>\n<td>created</td>\n<td>实例创建完成，可以访问到 <code>data</code>,<code>computed</code>,<code>watch</code>,<code>methods</code>上的数据和方法，未挂载到dom 上，不能访问<code>#el</code> 属性， <code>$ref</code>属性d额内容为空数组</td>\n<td>常用语简单的<code>ajax请求</code>,页面的初始化</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>在挂载开始前被调用，<code>beforeMount</code>之前，会找到对应的<code>template</code>，并编译成<code>render</code>函数</td>\n<td>-</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>实例挂载到DOM上，此时可以通过<code>DOM API</code> 获取到<code>DOM</code> 节点，<code>$ref</code> 属性可以访问</td>\n<td>常用于获取vnode信息和操作，<code>ajax</code>请求</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>响应式数据更新时调用，发生在虚拟DOM打补丁之前</td>\n<td>适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</td>\n<td>避免在这个钩子函数中操作数据，可能陷入死循环</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>实例销毁之前调用。这一步，实力任然完全可用，<code>this</code>仍能获取到实例</td>\n<td>常用于销毁定时器，解绑迁居时间，销毁插件对象等操作</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>实力销毁后调用，调用后，Vue实例只是的所有东西都会解绑，所有的事件监听器会被移除，所有的姿势里也会被销毁</td>\n<td>在此也可以用于销毁定时器</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<!-- - beforeCreate: \n  - 组件状态： 实例初始化之后,this指向创建的实例，此时还不能访问到`data`,`computed`,`watch`,`methods`上的数据和方法\n  - 最佳实践：常用于初始化非响应式变量\n- created:\n  - 组件状态：实例创建完成，可以访问到 `data`,`computed`,`watch`,`methods`上的数据和方法，未挂载到dom 上，不能访问`#el` 属性， `$ref`属性d额内容为空数组\n  - 最佳实践：常用语简单的`ajax请求`,页面的初始化  \n- beforeMount: \n  - 组件状态：在挂载开始前被调用，`beforeMount`之前，会找到对应的`template`，并编译成`render`函数\n- mounted:\n  - 组件状态：实例挂载到DOM上，此时可以通过`DOM API` 获取到`DOM` 节点，`$ref` 属性可以访问\n  - 最佳实践：常用于获取vnode信息和操作，`ajax`请求\n- beforeUpdate:\n  - 组件状态：响应式数据更新时调用，发生在虚拟DOM打补丁之前\n  - 最佳实践：适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器\n- updated:\n  - 组件状态：虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作\n  - 最佳实践：避免在这个钩子函数中操作数据，可能陷入死循环\n- beforeDestroy:\n   - 组件状态：实例销毁之前调用。这一步，实力任然完全可用，`this`仍能获取到实例\n   - 最佳实践：常用于销毁定时器，解绑迁居时间，销毁插件对象等操作\n- destroyed:\n  - 组件状态：实力销毁后调用，调用后，Vue实例只是的所有东西都会解绑，所有的事件监听器会被移除，所有的姿势里也会被销毁  \n  - 最佳实践：在此也可以用于销毁定时器， -->\n<p>注：</p>\n<ul>\n<li>\n<p>created阶段的<code>ajax</code>请求与<code>mounted</code>请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，此时如果做<code>DOM</code>请求时会报错,页面还没有渲染出来</p>\n</li>\n<li>\n<p>mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <a href=\"https://blog.csdn.net/shuidinaozhongyan/article/details/72630573\" target=\"_blank\" rel=\"noopener noreferrer\"><code>vm.$nextTick</code><OutboundLink/></a>\n(https://blog.csdn.net/sinat_17775997/article/details/71638144)</p>\n</li>\n<li>\n<p><code>beforeCreate</code>，<code>created</code>，<code>beforeMount</code>，<code>mounted</code> 是自动被调用</p>\n</li>\n<li>\n<p><code>beforeUpdate</code>, <code>updated</code>,<code>beforeDestroy</code>,<code>destroyed</code> 是手动调用</p>\n</li>\n<li>\n<p>子组件的<code>created</code> 优先于父组件的<code>created</code> 执行， 父组件的<code>beforeCreate</code> 优先于子组件的<code>beforeCreate</code></p>\n</li>\n<li>\n<p>子组件的<code>mounted</code>优先于父组件的<code>mounted</code>， 父组件的<code>beforeMount</code> 优先于子组件的 <code>beforeMount</code></p>\n</li>\n<li>\n<p>子组件的<code>destroyed</code>优先于父组件的<code>beforeDestroy</code>， 父组件的<code>beforeDestroy</code> 优先于子组件的 <code>beforeDestroy</code></p>\n</li>\n</ul>\n<h2 id=\"activated-deactivated\"><a class=\"header-anchor\" href=\"#activated-deactivated\" aria-hidden=\"true\">#</a> activated &amp; deactivated</h2>\n<p>最后还有 两个钩子函数没显示：activated &amp; deactivated\n使用<code>&lt;keep-alive&gt;</code>会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务</p>\n<ul>\n<li>\n<p>activated： 在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用，该钩子在服务器端渲染期间不被调用。</p>\n</li>\n<li>\n<p>deactivated： keep-alive组件停用时调用。该钩子在服务端渲染期间不被调用。</p>\n<p>组件内的离开当前路由钩子beforeRouteLeave =&gt;  路由前置守卫 beforeEach =&gt;\n全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由)\n// 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated\n// 如果进入的路由也没有缓存的话  全局后置钩子afterEach=&gt;销毁 destroyed=&gt; beforeCreate等</p>\n</li>\n</ul>\n<h2 id=\"路由导航守卫\"><a class=\"header-anchor\" href=\"#路由导航守卫\" aria-hidden=\"true\">#</a> 路由导航守卫</h2>\n<p><a href=\"https://juejin.im/post/5b41bdef6fb9a04fe63765f1\" target=\"_blank\" rel=\"noopener noreferrer\">Vue的钩子函数 [路由导航守卫、keep-alive、生命周期钩子]<OutboundLink/></a></p>\n<p>实例demo：\n见<a href=\"https://github.com/Littlombie/Vue-analysis/tree/master/02-lifeCycle/template\" target=\"_blank\" rel=\"noopener noreferrer\"><code>template</code><OutboundLink/></a>\n<!-- \n![](https://files.jb51.net/file_images/article/201709/2017927151335093.png?2017827151357) -->\n参考文档：<br>\n<a href=\"https://juejin.im/post/5ad10800f265da23826e681e?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\" target=\"_blank\" rel=\"noopener noreferrer\">如何解释vue的生命周期才能令面试官满意？<OutboundLink/></a><br>\n<a href=\"http://blog.poetries.top/2018/08/26/vue-lifecircle/?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\" target=\"_blank\" rel=\"noopener noreferrer\">vue生命周期（五）<OutboundLink/></a><br>\n<a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651555022&amp;idx=1&amp;sn=552856ad4af7bb9560217f6deec65270&amp;chksm=8025530fb752da190830e52ca6a9b24d1e7440e1d6cccbfff6355f7583d4f4749400e541739e\" target=\"_blank\" rel=\"noopener noreferrer\">深入 Vue 生命周期<OutboundLink/></a><br>\n<a href=\"https://segmentfault.com/a/1190000008771768?_ea=1739750\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 实例中的生命周期钩子详解<OutboundLink/></a><br>\n<a href=\"https://www.cnblogs.com/locim/p/8892738.html\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js源码解读<OutboundLink/></a><br>\n<a href=\"http://blog.51cto.com/9195095/1963227\" target=\"_blank\" rel=\"noopener noreferrer\">生命周期<OutboundLink/></a>\n<a href=\"https://juejin.im/post/5b41bdef6fb9a04fe63765f1\" target=\"_blank\" rel=\"noopener noreferrer\">Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]<OutboundLink/></a><br>\n<a href=\"https://blog.csdn.net/xdnloveme/article/details/78035065\" target=\"_blank\" rel=\"noopener noreferrer\">Vue生命周期中mounted和created的区别<OutboundLink/></a><br>\n<a href=\"https://www.jb51.net/article/124737.htm\" target=\"_blank\" rel=\"noopener noreferrer\">深入理解Vue生命周期、手动挂载及挂载子组件<OutboundLink/></a></p>\n<h2 id=\"遗留问题：\"><a class=\"header-anchor\" href=\"#遗留问题：\" aria-hidden=\"true\">#</a> 遗留问题：</h2>\n<ul>\n<li>\n<p>兄弟组件通过bus传值时的updated，beforeUpdate 生命周期顺序<br>\n如果是通过父级派发更新事件时，beforeUpdate，和updated的顺序 都是自上到下正常顺序进行；<br>\n如果是兄弟组件的派发顺序是beforeUpdate是从上到下，updated 的顺序是从下到上的更新顺序</p>\n</li>\n<li>\n<p>beforeCreate 有什么具体实际的用处，例举<br>\nvue生命周期中 beforeCreate 是实例初始化完成后数据观测（data observer）和event/watcher之前被调用。</p>\n<p>在beforeCreate前，所有的options都会先存到vm.$options中，在beforeCreate之后，将$options里的data啦，props啦，methods啦等等一个个附到vm上，然后再触发created钩子。所以在beforeCreate的时候，通过this.message是拿不到值的，在created的时候就能通过this.message拿到值了。</p>\n<p>一定要在beforeCreate的时候就同步去拿data里的值的话，就是直接从this.$options.data里去拿。如果data中的初始值是简单的string，那直接this.$options.data()[&quot;message&quot;]就好.涉及到复杂点的情况，建议看看源码里是怎么处理的，具体在core/instance/state.js中的initData(vm)里。\n还有一种方法 可以使用nextTick()，相当于做个延迟，等页面挂载完后在执行\n使用promise</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">let</span> <span class=\"token constant\">F</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n    <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n            dataList<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">beforeCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token constant\">F</span> <span class=\"token operator\">=</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token comment\">//fetchData是取数方法</span>\n            <span class=\"token comment\">//...返回promise</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">created</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token constant\">F</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>data<span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dataList <span class=\"token operator\">=</span> data\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>本人理解其中原因就是一个实例初始化后的提示功能，表示此后要开始</p>\n</li>\n</ul>\n</div>\n",null]}